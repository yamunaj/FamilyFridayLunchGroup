# Lunch Group Generation

## Steps to Execute
### Execute Program
* A script is provided as a wrapper to invoke the executable
* To compile, run `sh compile.sh`
	- Options to run should be self evident
	- The initial set of names can be input using a text file or can be entered one by one using `Add New Employee` option.
	- Compilation should not fail
	- If it fails rest of the steps will not execute
* From terminal, run `sh run.sh`

### Run Tests
* To run all tests do `sh runAllTests.sh 2>/dev/null`
* To enable verbose logging, do `sh runAllTests.sh`


## Assumptions
The git repository is setup such that directories are downloaded in the way it should be structured.

1. The executable will be generated under `<project_dir>/...`
2. Test files and scripts (explained below) needs to be in the same directory where the executable is
3. Scripts assumes you are in bash environment

## Components
1. Java Files
	* `LunchGroup.java`
	* `SerializeDeserialize.java`

2. Executables
	* `LunchGroup.jar`
	* `run.sh` (script)

3. Auto generated Files
	* `EmployeesTable`
		- Serialized File with list of all employees
		- This is where the persistent data is stored

	* `LunchGroup.txt`
		- Output file
		- List of all lunch groups generated

4. Test scripts
	* `runAllTests.s`
		- Top level script
		- Invokes the following scripts
			* `Test[1-7]/Test[1-7].sh`
			* `Test[1-7]/Test[1-7].txt`

## Testcases Covered
### Test1
- Tests a basic file input and generation of lunch group from it

### Test2 
- Tests a very large input file

### Test3
- Tests adding new employees

### Test4
- Tests multiple new employees, listing all employees, deleting an employee

### Test5
- Tests no input file, input empty file
- Creation of lunch group when there is only a 1,2,3 users in the company

### Test6
- Tests persistence of data via existence of `EmployeesTable`

### Test7
- Tests wrong input file name or file path

## Implementation Details

1. All the employees in the company is stored in a Hashtable with the Employee Id as key and name of the employee as value.
    * For persistence this structure is serialized and written to EmployeesTable file.
        * If the file is found, program resumes using this data. If not, it asks for an input filename to start with.
        * If the input file is not given or empty then the program continues with an empty structure assuming there are no employees in the company.

2. For creating the lunch group, I am copying the keys in the hashtable to an array, shuffle the array and split the array in groups of 5.
    * If any group has < 3 members then 1 or 2 members are added from another 5 member group.

3. A new employee can be added by selecting the option 2.
4. The employee Id is auto generated by the program.
5. An employee can be deleted by selecting option 3 and giving the employee id of the person to be deleted. I gave this option in case if there is an erroneous entry or if an employee leaves the company.
6. Option 4 gives the list of employees with their employee ids.

### Decisions Made
1. One question I had while creating a lunch group was whether we need to remember lunchgrouping.
    * Then the members must be selected such that they were not grouped together the previously (like a graph connectivity problem).
    * This will require additional storage, as an adjacency matrix.
    * As the requirements did not specifically mention that a repetition of pairing (2 people getting into a group together more than once) needs to be avoided, I made the simple and straight forward implementation.

2. Another decision I made was whether to save the hashtable keys in an array to save me from querying for hashtable keys everytime we create the lunch group. But in Java, hashtable's keySet() API is a O(1) operation. So I made choice to not optimize this further.
    * Arrays.shuffle() in Java is an O(n) operation where 'n' is the number of employees; and we require no additional storage/sort (in the order of groups) for managing the lunch group output.
    * Specifically, to create groups we just have to iterate through the shuffled array once. So the complexity for that becomes O(n).

To conclude, by this implementation

- Creation of lunch groups: the complexity for my implementation is O(n)
- Adding or deleting an employee takes O(1) (assuming no collision).

## Environment Used for Testing
- OSX 10.13.2 with default shell
- Java version: 9.0.1